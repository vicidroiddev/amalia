{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Amalia \u00b6 What is Amalia? \u00b6 Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process. Features \u00b6 100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Overview"},{"location":"#amalia","text":"","title":"Amalia"},{"location":"#what-is-amalia","text":"Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process.","title":"What is Amalia?"},{"location":"#features","text":"100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Features"},{"location":"changelog/","text":"Changelog - Amalia \u00b6 Amalia 0.6.9 \u00b6 2020-04_29 Library changes: \u00b6 Rename RecyclerViewEvent to AmaliaCommonEvent Amalia 0.6.8 \u00b6 2020-04_29 Library changes: \u00b6 Fix index out of bounds error on recycler view ( https://github.com/vicidroiddev/amalia/issues/26 ) Amalia 0.6.7 \u00b6 2020-04_09 Library changes: \u00b6 Remove state and event type signature from ListViewDelegate Amalia 0.6.1 \u00b6 2020-04_08 Library changes: \u00b6 Fixed crash when leveraging PresenterProvider for multiple presenters from Java Ensure presenter tells view delegate it has has been bound via onBindViewDelegate() Reduced restriction on ViewState for RecyclerViewDelegate Allow tracking of recycler view items via event propagation Remove type signatures from presenters and view delegates to allow for better generic reuse Dependency updates: \u00b6 See commit for details: gradle plugin, gradle wrapper junit, kotlin, lifecycle appcompat, corektx, constraintlayout, recyclerview, savedstate mockito, roboelectric, coroutines material, retrofit, moshi, glide, leak canary Amalia 0.4.1 \u00b6 2019-10_18 Library changes: \u00b6 ViewDelegates can now intercept view events to easily apply lateinit fields residing in some BaseEvent Amalia 0.4.0 \u00b6 2019-10_02 New module: \u00b6 RecyclerView support Can support numerous presenters that rely on different recycler items Library changes: \u00b6 Add feature logging capability for presenters and recyclerviews, see Logging.kt Allow child presenter provider to leverage hooks for applying common fields to base presenters View delegates now post onViewAttached() on next event loop bindViewLifecycleOwner() has been renamed to regular bind(). There are now 3 bind methods to choose from, check documentation for more info. presenterLifeCycleOwner field has been removed onPresenterDestroyed() was previously not invoked on child presenters onCleared has been made final, rely on #onPresenterDestroyed instead Dependency updates: \u00b6 Updated Coroutine library to 1.3.0 for scope support Updated Kotlin to 1.3.50 Updated Build tools to 29.0.2 Amalia 0.3.7 \u00b6 2019-08_14 Library changes: \u00b6 Fix dependency issues with samples Amalia 0.3.6 \u00b6 2019-07_06 Library changes: \u00b6 Name space for library changed after adding second gradle module, docs reflect proper names. Amalia 0.3.5 \u00b6 2019-07_06 Library changes: \u00b6 Ensure coroutine scopes is present as separate android artifact Amalia 0.3.4 \u00b6 2019-06_26 Library changes: \u00b6 More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scopes as extension property to presenters ( https://github.com/vicidroiddev/amalia/issues/12 ) Amalia 0.3.3 \u00b6 2019-06_15 Library changes: \u00b6 Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 ) Amalia 0.3.2 \u00b6 2019-06_11 Library changes: \u00b6 Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f ) Amalia 0.3.1 \u00b6 2019-06-10 Library changes: \u00b6 Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 ) Amalia 0.3.0 \u00b6 2019-06-09 Note: This version will rely on android x saved state library to be included in your app. Library changes: \u00b6 Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 ) Dependency updates: \u00b6 com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test 1.3.0-alpha01 Amalia 0.2.0 \u00b6 2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Change Log"},{"location":"changelog/#changelog-amalia","text":"","title":"Changelog - Amalia"},{"location":"changelog/#amalia-069","text":"2020-04_29","title":"Amalia 0.6.9"},{"location":"changelog/#library-changes","text":"Rename RecyclerViewEvent to AmaliaCommonEvent","title":"Library changes:"},{"location":"changelog/#amalia-068","text":"2020-04_29","title":"Amalia 0.6.8"},{"location":"changelog/#library-changes_1","text":"Fix index out of bounds error on recycler view ( https://github.com/vicidroiddev/amalia/issues/26 )","title":"Library changes:"},{"location":"changelog/#amalia-067","text":"2020-04_09","title":"Amalia 0.6.7"},{"location":"changelog/#library-changes_2","text":"Remove state and event type signature from ListViewDelegate","title":"Library changes:"},{"location":"changelog/#amalia-061","text":"2020-04_08","title":"Amalia 0.6.1"},{"location":"changelog/#library-changes_3","text":"Fixed crash when leveraging PresenterProvider for multiple presenters from Java Ensure presenter tells view delegate it has has been bound via onBindViewDelegate() Reduced restriction on ViewState for RecyclerViewDelegate Allow tracking of recycler view items via event propagation Remove type signatures from presenters and view delegates to allow for better generic reuse","title":"Library changes:"},{"location":"changelog/#dependency-updates","text":"See commit for details: gradle plugin, gradle wrapper junit, kotlin, lifecycle appcompat, corektx, constraintlayout, recyclerview, savedstate mockito, roboelectric, coroutines material, retrofit, moshi, glide, leak canary","title":"Dependency updates:"},{"location":"changelog/#amalia-041","text":"2019-10_18","title":"Amalia 0.4.1"},{"location":"changelog/#library-changes_4","text":"ViewDelegates can now intercept view events to easily apply lateinit fields residing in some BaseEvent","title":"Library changes:"},{"location":"changelog/#amalia-040","text":"2019-10_02","title":"Amalia 0.4.0"},{"location":"changelog/#new-module","text":"RecyclerView support Can support numerous presenters that rely on different recycler items","title":"New module:"},{"location":"changelog/#library-changes_5","text":"Add feature logging capability for presenters and recyclerviews, see Logging.kt Allow child presenter provider to leverage hooks for applying common fields to base presenters View delegates now post onViewAttached() on next event loop bindViewLifecycleOwner() has been renamed to regular bind(). There are now 3 bind methods to choose from, check documentation for more info. presenterLifeCycleOwner field has been removed onPresenterDestroyed() was previously not invoked on child presenters onCleared has been made final, rely on #onPresenterDestroyed instead","title":"Library changes:"},{"location":"changelog/#dependency-updates_1","text":"Updated Coroutine library to 1.3.0 for scope support Updated Kotlin to 1.3.50 Updated Build tools to 29.0.2","title":"Dependency updates:"},{"location":"changelog/#amalia-037","text":"2019-08_14","title":"Amalia 0.3.7"},{"location":"changelog/#library-changes_6","text":"Fix dependency issues with samples","title":"Library changes:"},{"location":"changelog/#amalia-036","text":"2019-07_06","title":"Amalia 0.3.6"},{"location":"changelog/#library-changes_7","text":"Name space for library changed after adding second gradle module, docs reflect proper names.","title":"Library changes:"},{"location":"changelog/#amalia-035","text":"2019-07_06","title":"Amalia 0.3.5"},{"location":"changelog/#library-changes_8","text":"Ensure coroutine scopes is present as separate android artifact","title":"Library changes:"},{"location":"changelog/#amalia-034","text":"2019-06_26","title":"Amalia 0.3.4"},{"location":"changelog/#library-changes_9","text":"More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scopes as extension property to presenters ( https://github.com/vicidroiddev/amalia/issues/12 )","title":"Library changes:"},{"location":"changelog/#amalia-033","text":"2019-06_15","title":"Amalia 0.3.3"},{"location":"changelog/#library-changes_10","text":"Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 )","title":"Library changes:"},{"location":"changelog/#amalia-032","text":"2019-06_11","title":"Amalia 0.3.2"},{"location":"changelog/#library-changes_11","text":"Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f )","title":"Library changes:"},{"location":"changelog/#amalia-031","text":"2019-06-10","title":"Amalia 0.3.1"},{"location":"changelog/#library-changes_12","text":"Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 )","title":"Library changes:"},{"location":"changelog/#amalia-030","text":"2019-06-09 Note: This version will rely on android x saved state library to be included in your app.","title":"Amalia 0.3.0"},{"location":"changelog/#library-changes_13","text":"Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Library changes:"},{"location":"changelog/#dependency-updates_2","text":"com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test 1.3.0-alpha01","title":"Dependency updates:"},{"location":"changelog/#amalia-020","text":"2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Amalia 0.2.0"},{"location":"gettingstarted/","text":"Adding gradle dependency \u00b6 Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url 'https://jitpack.io' } } } Now add the amalia dependency in your app level build.gradle file. implementation ( \"com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar\" ) { transitive = true } 1. Define states and events \u00b6 You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state -> ViewDelegate renders the state ViewDelegate pushes event -> Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () } 2. Define presenter \u00b6 Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate ) { Log . v ( \"DiscoverPresenter\" , \"View was bound to presenter\" ) } override fun onViewEvent ( event : ViewEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite -> { repository . saveFavouriteShow ( event . show ) } } } } 3. Define view delegate \u00b6 Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate < DiscoverTvState , DiscoverTvEvent >( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded -> { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } } 4. Bind the presenter and delegate \u00b6 Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"Getting Started"},{"location":"gettingstarted/#adding-gradle-dependency","text":"Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url 'https://jitpack.io' } } } Now add the amalia dependency in your app level build.gradle file. implementation ( \"com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar\" ) { transitive = true }","title":"Adding gradle dependency"},{"location":"gettingstarted/#1-define-states-and-events","text":"You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state -> ViewDelegate renders the state ViewDelegate pushes event -> Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () }","title":"1. Define states and events"},{"location":"gettingstarted/#2-define-presenter","text":"Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate ) { Log . v ( \"DiscoverPresenter\" , \"View was bound to presenter\" ) } override fun onViewEvent ( event : ViewEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite -> { repository . saveFavouriteShow ( event . show ) } } } }","title":"2. Define presenter"},{"location":"gettingstarted/#3-define-view-delegate","text":"Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate < DiscoverTvState , DiscoverTvEvent >( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded -> { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } }","title":"3. Define view delegate"},{"location":"gettingstarted/#4-bind-the-presenter-and-delegate","text":"Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"4. Bind the presenter and delegate"},{"location":"components/presenters/","text":"Presenters \u00b6 Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState(...) to expose a meaningful ViewState . Should inherit from BasePresenter Should override onViewEvent(...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration Is there a callback for when my presenter is ready to go? \u00b6 class MyPresenter : BasePresenter () { override fun loadInitialState () { // Can access applicationContext at this point applicationContext . getString ( R . string . somestring ) } } Is there a callback for when my presenter is destroyed? \u00b6 onPresenterDestroyed() will be invoked when the presenter is about to die. This will also be called for child presenters. This method is not invoked on configuration changes. class MyPresenter : BasePresenter () { override fun onPresenterDestroyed () { // Clean up time // Even better track your closeable objects, see below } } What's a good way to clean up long running operations? \u00b6 You may store your object in the presenter cache if it implements Closeable . That way you can be sure it is automatically cleaned up at the right time. Note: Amalia uses this mechanism for amalia-coroutine-scopes module. class MyPresenter : BasePresenter () { init { val longRunningThing = LongRunningThing () // Objects will automatically have close() called when the presenter is destroyed. closeableObjects . put ( \"my_key\" , longRunningThing ) } // Ensure we implement Closeable and cancel any operations needed. class LongRunningThing : Closeable { override fun close () { // Stop long running thing } } } How do I use multiple presenters in Java? \u00b6 Warning Java does not support Kotlin reified types. As such the following signature cannot be used reliabily from Java: fun <reified P : BasePresenter> Fragment.presenterProvider(.....) While it is possible to write a wrapper, a casting error will occur if more than one presenter is invoked in a given java class. To get around this problem you could convert your class to Kotlin to make use of reified types. However, if conversion is not desired, it is possible to specify the reified types in a wrapper function that returns an exact type. Create a Kotlin file with one or many package level functions // MyProviders.kt fun provideFeature1Presenter ( fragment : Fragment ) : Feature1Presenter = fragment . presenterProviderExt { provideFeature1Presenter () }. value fun provideFeature2Presenter ( fragment : Fragment ) : Feature2Presenter = fragment . presenterProviderExt { provideFeature2Presenter () }. value Use those package functions from your java fragment public class MyFragment extends Fragment private Feature1Presenter mFeature1Presenter ; private Feature2Presenter mFeature2Presenter ; @Override public void onViewCreated ( final View view , @Nullable final Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ); mFeature1Presenter = provideFeature1Presenter ( this ); mFeature2Presenter = provideFeature2Presenter ( this ); }","title":"Presenters"},{"location":"components/presenters/#presenters","text":"Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState(...) to expose a meaningful ViewState . Should inherit from BasePresenter Should override onViewEvent(...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration","title":"Presenters"},{"location":"components/presenters/#is-there-a-callback-for-when-my-presenter-is-ready-to-go","text":"class MyPresenter : BasePresenter () { override fun loadInitialState () { // Can access applicationContext at this point applicationContext . getString ( R . string . somestring ) } }","title":"Is there a callback for when my presenter is ready to go?"},{"location":"components/presenters/#is-there-a-callback-for-when-my-presenter-is-destroyed","text":"onPresenterDestroyed() will be invoked when the presenter is about to die. This will also be called for child presenters. This method is not invoked on configuration changes. class MyPresenter : BasePresenter () { override fun onPresenterDestroyed () { // Clean up time // Even better track your closeable objects, see below } }","title":"Is there a callback for when my presenter is destroyed?"},{"location":"components/presenters/#whats-a-good-way-to-clean-up-long-running-operations","text":"You may store your object in the presenter cache if it implements Closeable . That way you can be sure it is automatically cleaned up at the right time. Note: Amalia uses this mechanism for amalia-coroutine-scopes module. class MyPresenter : BasePresenter () { init { val longRunningThing = LongRunningThing () // Objects will automatically have close() called when the presenter is destroyed. closeableObjects . put ( \"my_key\" , longRunningThing ) } // Ensure we implement Closeable and cancel any operations needed. class LongRunningThing : Closeable { override fun close () { // Stop long running thing } } }","title":"What's a good way to clean up long running operations?"},{"location":"components/presenters/#how-do-i-use-multiple-presenters-in-java","text":"Warning Java does not support Kotlin reified types. As such the following signature cannot be used reliabily from Java: fun <reified P : BasePresenter> Fragment.presenterProvider(.....) While it is possible to write a wrapper, a casting error will occur if more than one presenter is invoked in a given java class. To get around this problem you could convert your class to Kotlin to make use of reified types. However, if conversion is not desired, it is possible to specify the reified types in a wrapper function that returns an exact type. Create a Kotlin file with one or many package level functions // MyProviders.kt fun provideFeature1Presenter ( fragment : Fragment ) : Feature1Presenter = fragment . presenterProviderExt { provideFeature1Presenter () }. value fun provideFeature2Presenter ( fragment : Fragment ) : Feature2Presenter = fragment . presenterProviderExt { provideFeature2Presenter () }. value Use those package functions from your java fragment public class MyFragment extends Fragment private Feature1Presenter mFeature1Presenter ; private Feature2Presenter mFeature2Presenter ; @Override public void onViewCreated ( final View view , @Nullable final Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ); mFeature1Presenter = provideFeature1Presenter ( this ); mFeature2Presenter = provideFeature2Presenter ( this ); }","title":"How do I use multiple presenters in Java?"},{"location":"components/viewdelegates/","text":"ViewDelegates \u00b6 Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate Should override renderViewState(...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent(...) to expose a meaningful ViewEvent How do I apply important fields to all events? \u00b6 You likely have a base class for your own MyAppBaseViewDelegate . In there you can override onInterceptEventChain() . // Create your base view event. All of your view events should extend from this event open class BaseDefaultViewEvent : ViewEvent { lateinit var importantSharedField : String } // Create your own variant of a BaseMyAppViewDelegate // Note that the event extends from `BaseDefaultViewEvent` abstract class MyAppBaseViewDelegate ( view : View , lifecycleOwner : LifecycleOwner ) : BaseViewDelegate ( lifecycleOwner , view ) { // Override this method and inject any fields you defined override fun onInterceptEventChain ( event : ViewEvent ) { event . importantSharedField = provideImportantField () } abstract fun provideImportantField () : String }","title":"View Delegate"},{"location":"components/viewdelegates/#viewdelegates","text":"Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate Should override renderViewState(...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent(...) to expose a meaningful ViewEvent","title":"ViewDelegates"},{"location":"components/viewdelegates/#how-do-i-apply-important-fields-to-all-events","text":"You likely have a base class for your own MyAppBaseViewDelegate . In there you can override onInterceptEventChain() . // Create your base view event. All of your view events should extend from this event open class BaseDefaultViewEvent : ViewEvent { lateinit var importantSharedField : String } // Create your own variant of a BaseMyAppViewDelegate // Note that the event extends from `BaseDefaultViewEvent` abstract class MyAppBaseViewDelegate ( view : View , lifecycleOwner : LifecycleOwner ) : BaseViewDelegate ( lifecycleOwner , view ) { // Override this method and inject any fields you defined override fun onInterceptEventChain ( event : ViewEvent ) { event . importantSharedField = provideImportantField () } abstract fun provideImportantField () : String }","title":"How do I apply important fields to all events?"},{"location":"components/viewevents/","text":"ViewEvent \u00b6 Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent(event: E) to receive the SaveProfile event that was just sent.","title":"View Event"},{"location":"components/viewevents/#viewevent","text":"Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent(event: E) to receive the SaveProfile event that was just sent.","title":"ViewEvent"},{"location":"components/viewstates/","text":"ViewState \u00b6 Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState(state: S) to receive the ProfileLoaded state that was just sent.","title":"View State"},{"location":"components/viewstates/#viewstate","text":"Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState(state: S) to receive the ProfileLoaded state that was just sent.","title":"ViewState"},{"location":"modules/coroutinescopes/","text":"Coroutine Scopes \u00b6 All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider . Available scopes in a presenter extending from <BasePresenter \u00b6 mainScope . launch { //uses the coroutine Main dispatcher, preferred scope for presenters } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher } Adding gradle dependency \u00b6 Add the amalia dependency in your app level build.gradle file. implementation 'com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar' Example usage: \u00b6 class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Coroutine Scopes"},{"location":"modules/coroutinescopes/#coroutine-scopes","text":"All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider .","title":"Coroutine Scopes"},{"location":"modules/coroutinescopes/#available-scopes-in-a-presenter-extending-frombasepresenter","text":"mainScope . launch { //uses the coroutine Main dispatcher, preferred scope for presenters } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher }","title":"Available scopes in a presenter extending from&lt;BasePresenter"},{"location":"modules/coroutinescopes/#adding-gradle-dependency","text":"Add the amalia dependency in your app level build.gradle file. implementation 'com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar'","title":"Adding gradle dependency"},{"location":"modules/coroutinescopes/#example-usage","text":"class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Example usage:"},{"location":"modules/modules/","text":"Dependencies \u00b6 Amalia Core \u00b6 implementation ( \"com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar\" ) { transitive = true } Coroutine Scope Helper \u00b6 implementation 'com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar' RecyclerView Helper (0.4.0+) \u00b6 implementation 'com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar'","title":"Dependencies"},{"location":"modules/modules/#dependencies","text":"","title":"Dependencies"},{"location":"modules/modules/#amalia-core","text":"implementation ( \"com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar\" ) { transitive = true }","title":"Amalia Core"},{"location":"modules/modules/#coroutine-scope-helper","text":"implementation 'com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar'","title":"Coroutine Scope Helper"},{"location":"modules/modules/#recyclerview-helper-040","text":"implementation 'com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar'","title":"RecyclerView Helper (0.4.0+)"},{"location":"modules/recyclerview/","text":"RecyclerView Backed Delegates \u00b6 This module gives plug and play support for simple and complex lists. You can build complex dashboards where each item in the RecyclerView is backed by a different presenter. If each card needs to own its own logic for when to display - NO problem. You can also create simple lists that are composed of different view items, such as cards, headers, etc... Out of the box you will get: Async diff support (send a bunch of items via pushState, only the items that changed will be processed) A wrapper around RecyclerView that allows you to focus on your own display logic Optional tracking of items seen via event propagation to your presenter Adding gradle dependency \u00b6 Add the amalia dependency in your app level build.gradle file. implementation 'com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar' 1. Create your own RecyclerViewDelegate \u00b6 This is the view layer. You likely won't have much code to put in here. You can customize some options such as spacing or layout managers for the recyclerview if needed. See the constructor for additional options. class MyLongListViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : RecyclerViewDelegate < DiscoverTvItem , DiscoverTvItem . ViewHolder >( lifecycleOwner , view , R . id . the_recyclerview_id , trackItemsSeen = true /* optional */ ) { } 2. Create a recycler item to bind data to view \u00b6 class MyRecyclerViewItem ( val myItem : MyItem ) : BaseRecyclerItem < DiscoverTvItem . ViewHolder >( discoverResult ) { // Pass a layout represented by the given item to display - CardView for example override val layoutRes = R . layout . my_list_item_layout override fun createViewHolder ( itemView : View ) = MyViewHolder ( itemView ) override fun bind ( viewHolder : ViewHolder , payloads : List < ChangePayload < DiffItem >>) { with ( viewHolder ) { // bind myItem to the view here name . text = myItem . name } } class MyViewHolder ( itemView : View ) : BaseRecyclerViewHolder ( itemView ) { val name : TextView = findViewById ( R . id . my_name ) init { // Set onclick listeners here or any other view listeners // Push events here to be processed by your presenter } } } 3. Emit recycler items with a presenter \u00b6 class MyLongListPresenter ( private val repository : MyRepository ) : BasePresenter (), Refreshable { private var results : MutableList < DiscoverResult > = mutableListOf () override fun loadInitialState () { mainScope . launch { // Make a suspending call that could be expensive, get a long list of items from a db for example. val items = repository . fetchItems () // Convert that data item (regular POJO class) to a RecyclerItem val viewItems = items . map { myItem -> MyRecyclerViewItem ( myItem ) } pushState ( RecyclerViewState . ListLoaded ( viewItems )) } } } 4. Don't forget to bind the presenter and delegate! \u00b6 See getting started section for how to perform binding.","title":"RecyclerView Delegate"},{"location":"modules/recyclerview/#recyclerview-backed-delegates","text":"This module gives plug and play support for simple and complex lists. You can build complex dashboards where each item in the RecyclerView is backed by a different presenter. If each card needs to own its own logic for when to display - NO problem. You can also create simple lists that are composed of different view items, such as cards, headers, etc... Out of the box you will get: Async diff support (send a bunch of items via pushState, only the items that changed will be processed) A wrapper around RecyclerView that allows you to focus on your own display logic Optional tracking of items seen via event propagation to your presenter","title":"RecyclerView Backed Delegates"},{"location":"modules/recyclerview/#adding-gradle-dependency","text":"Add the amalia dependency in your app level build.gradle file. implementation 'com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar'","title":"Adding gradle dependency"},{"location":"modules/recyclerview/#1-create-your-own-recyclerviewdelegate","text":"This is the view layer. You likely won't have much code to put in here. You can customize some options such as spacing or layout managers for the recyclerview if needed. See the constructor for additional options. class MyLongListViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : RecyclerViewDelegate < DiscoverTvItem , DiscoverTvItem . ViewHolder >( lifecycleOwner , view , R . id . the_recyclerview_id , trackItemsSeen = true /* optional */ ) { }","title":"1. Create your own RecyclerViewDelegate"},{"location":"modules/recyclerview/#2-create-a-recycler-item-to-bind-data-to-view","text":"class MyRecyclerViewItem ( val myItem : MyItem ) : BaseRecyclerItem < DiscoverTvItem . ViewHolder >( discoverResult ) { // Pass a layout represented by the given item to display - CardView for example override val layoutRes = R . layout . my_list_item_layout override fun createViewHolder ( itemView : View ) = MyViewHolder ( itemView ) override fun bind ( viewHolder : ViewHolder , payloads : List < ChangePayload < DiffItem >>) { with ( viewHolder ) { // bind myItem to the view here name . text = myItem . name } } class MyViewHolder ( itemView : View ) : BaseRecyclerViewHolder ( itemView ) { val name : TextView = findViewById ( R . id . my_name ) init { // Set onclick listeners here or any other view listeners // Push events here to be processed by your presenter } } }","title":"2. Create a recycler item to bind data to view"},{"location":"modules/recyclerview/#3-emit-recycler-items-with-a-presenter","text":"class MyLongListPresenter ( private val repository : MyRepository ) : BasePresenter (), Refreshable { private var results : MutableList < DiscoverResult > = mutableListOf () override fun loadInitialState () { mainScope . launch { // Make a suspending call that could be expensive, get a long list of items from a db for example. val items = repository . fetchItems () // Convert that data item (regular POJO class) to a RecyclerItem val viewItems = items . map { myItem -> MyRecyclerViewItem ( myItem ) } pushState ( RecyclerViewState . ListLoaded ( viewItems )) } } }","title":"3. Emit recycler items with a presenter"},{"location":"modules/recyclerview/#4-dont-forget-to-bind-the-presenter-and-delegate","text":"See getting started section for how to perform binding.","title":"4. Don't forget to bind the presenter and delegate!"}]}