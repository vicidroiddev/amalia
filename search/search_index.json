{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Amalia What is Amalia? Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process. Features 100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Overview"},{"location":"#amalia","text":"","title":"Amalia"},{"location":"#what-is-amalia","text":"Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process.","title":"What is Amalia?"},{"location":"#features","text":"100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Features"},{"location":"changelog/","text":"Changelog - Amalia Amalia 0.3.6 2019-07_06 Library changes: Name space for library changed after adding second gradle module, docs reflect proper names. Amalia 0.3.5 2019-07_06 Library changes: Ensure coroutine scopes is present as separate android artifact Amalia 0.3.4 2019-06_26 Library changes: More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scope to presenter #12 ( https://github.com/vicidroiddev/amalia/issues/12 ) Amalia 0.3.3 2019-06_15 Library changes: Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 ) Amalia 0.3.2 2019-06_11 Library changes: Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f ) Amalia 0.3.1 2019-06-10 Library changes: Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 ) Amalia 0.3.0 2019-06-09 Note: This version will rely on android x saved state library to be included in your app. Library changes: Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 ) Dependency updates: com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test:runner:1.3.0-alpha01 Amalia 0.2.0 2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Change Log"},{"location":"changelog/#changelog-amalia","text":"","title":"Changelog - Amalia"},{"location":"changelog/#amalia-036","text":"2019-07_06","title":"Amalia 0.3.6"},{"location":"changelog/#library-changes","text":"Name space for library changed after adding second gradle module, docs reflect proper names.","title":"Library changes:"},{"location":"changelog/#amalia-035","text":"2019-07_06","title":"Amalia 0.3.5"},{"location":"changelog/#library-changes_1","text":"Ensure coroutine scopes is present as separate android artifact","title":"Library changes:"},{"location":"changelog/#amalia-034","text":"2019-06_26","title":"Amalia 0.3.4"},{"location":"changelog/#library-changes_2","text":"More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scope to presenter #12 ( https://github.com/vicidroiddev/amalia/issues/12 )","title":"Library changes:"},{"location":"changelog/#amalia-033","text":"2019-06_15","title":"Amalia 0.3.3"},{"location":"changelog/#library-changes_3","text":"Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 )","title":"Library changes:"},{"location":"changelog/#amalia-032","text":"2019-06_11","title":"Amalia 0.3.2"},{"location":"changelog/#library-changes_4","text":"Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f )","title":"Library changes:"},{"location":"changelog/#amalia-031","text":"2019-06-10","title":"Amalia 0.3.1"},{"location":"changelog/#library-changes_5","text":"Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 )","title":"Library changes:"},{"location":"changelog/#amalia-030","text":"2019-06-09 Note: This version will rely on android x saved state library to be included in your app.","title":"Amalia 0.3.0"},{"location":"changelog/#library-changes_6","text":"Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Library changes:"},{"location":"changelog/#dependency-updates","text":"com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test:runner:1.3.0-alpha01","title":"Dependency updates:"},{"location":"changelog/#amalia-020","text":"2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Amalia 0.2.0"},{"location":"gettingstarted/","text":"Adding gradle dependency Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url https://jitpack.io } } } Now add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar 1. Define states and events You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state - ViewDelegate renders the state ViewDelegate pushes event - Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () } 2. Define presenter Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter DiscoverState , DiscoverEvent () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate DiscoverState , DiscoverEvent ) { Log . v ( DiscoverPresenter , View was bound to presenter ) } override fun onViewEvent ( event : DiscoverEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite - { repository . saveFavouriteShow ( event . show ) } } } } 3. Define view delegate Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate DiscoverTvState , DiscoverTvEvent ( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded - { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } } 4. Bind the presenter and delegate Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"Getting Started"},{"location":"gettingstarted/#adding-gradle-dependency","text":"Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url https://jitpack.io } } } Now add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar","title":"Adding gradle dependency"},{"location":"gettingstarted/#1-define-states-and-events","text":"You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state - ViewDelegate renders the state ViewDelegate pushes event - Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () }","title":"1. Define states and events"},{"location":"gettingstarted/#2-define-presenter","text":"Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter DiscoverState , DiscoverEvent () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate DiscoverState , DiscoverEvent ) { Log . v ( DiscoverPresenter , View was bound to presenter ) } override fun onViewEvent ( event : DiscoverEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite - { repository . saveFavouriteShow ( event . show ) } } } }","title":"2. Define presenter"},{"location":"gettingstarted/#3-define-view-delegate","text":"Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate DiscoverTvState , DiscoverTvEvent ( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded - { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } }","title":"3. Define view delegate"},{"location":"gettingstarted/#4-bind-the-presenter-and-delegate","text":"Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"4. Bind the presenter and delegate"},{"location":"components/coroutinescopes/","text":"Coroutine Scopes All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider . Available scopes in a presenter extending from BasePresenter * , * mainScope . launch { //uses the coroutine IO dispatcher } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher } Adding gradle dependency Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar Example usage: class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter DiscoverState , DiscoverEvent () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch ( Dispatchers . Main ) { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Coroutine Scopes"},{"location":"components/coroutinescopes/#coroutine-scopes","text":"All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider .","title":"Coroutine Scopes"},{"location":"components/coroutinescopes/#available-scopes-in-a-presenter-extending-frombasepresenter","text":"mainScope . launch { //uses the coroutine IO dispatcher } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher }","title":"Available scopes in a presenter extending from&lt;BasePresenter&lt;*,*&gt;"},{"location":"components/coroutinescopes/#adding-gradle-dependency","text":"Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar","title":"Adding gradle dependency"},{"location":"components/coroutinescopes/#example-usage","text":"class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter DiscoverState , DiscoverEvent () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch ( Dispatchers . Main ) { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Example usage:"},{"location":"components/presenters/","text":"Presenters Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState (...) to expose a meaningful ViewState . Should inherit from BasePresenter ViewState , ViewEvent Should override onViewEvent (...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration","title":"Presenters"},{"location":"components/presenters/#presenters","text":"Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState (...) to expose a meaningful ViewState . Should inherit from BasePresenter ViewState , ViewEvent Should override onViewEvent (...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration","title":"Presenters"},{"location":"components/recyclerview/","text":"RecyclerView Backed Delegates Coming soon. Will be tackled with https://github.com/vicidroiddev/amalia/issues/19 This should allow for complicated use cases where a recyclerview is backed by several presenters (Something like a dashboard view with multiple card types)","title":"Pending - RecyclerView Delegate"},{"location":"components/recyclerview/#recyclerview-backed-delegates","text":"Coming soon. Will be tackled with https://github.com/vicidroiddev/amalia/issues/19 This should allow for complicated use cases where a recyclerview is backed by several presenters (Something like a dashboard view with multiple card types)","title":"RecyclerView Backed Delegates"},{"location":"components/viewdelegates/","text":"ViewDelegates Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate ViewState , ViewEvent Should override renderViewState (...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent (...) to expose a meaningful ViewEvent","title":"View Delegate"},{"location":"components/viewdelegates/#viewdelegates","text":"Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate ViewState , ViewEvent Should override renderViewState (...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent (...) to expose a meaningful ViewEvent","title":"ViewDelegates"},{"location":"components/viewevents/","text":"ViewEvent Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent ( event : E ) to receive the SaveProfile event that was just sent.","title":"View Event"},{"location":"components/viewevents/#viewevent","text":"Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent ( event : E ) to receive the SaveProfile event that was just sent.","title":"ViewEvent"},{"location":"components/viewstates/","text":"ViewState Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState ( state : S ) to receive the ProfileLoaded state that was just sent.","title":"View State"},{"location":"components/viewstates/#viewstate","text":"Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState ( state : S ) to receive the ProfileLoaded state that was just sent.","title":"ViewState"}]}