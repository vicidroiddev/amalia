{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Amalia What is Amalia? Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process. Features 100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Overview"},{"location":"#amalia","text":"","title":"Amalia"},{"location":"#what-is-amalia","text":"Amalia is an MVP/MVI implementation dictating a straightforward uni-directional flow of view states to render and view events to process.","title":"What is Amalia?"},{"location":"#features","text":"100% Kotlin with pleasant apis that can still be consumed from Java Coroutine scope cancellation support via optional gradle dependency Decouple the UI from business logic but allow communication between the two Lifecycle-aware presenters which automatically clean up Modern Android Jetpack components presenters survive configuration changes via Jetpack's ViewModelStore presenters can receive lifecycle callbacks via a LifecycleOwner presenters are loosely coupled to views via LiveData observers presenters can recover from process death with the help of SavedStateRegistryOwner Structure legacy code without refactoring every single piece, even from Java. Prevent common crashes due to running code when view is not ready or destroyed.","title":"Features"},{"location":"changelog/","text":"Changelog - Amalia Amalia 0.4.0 2019-10_02 New module: RecyclerView support Can support numerous presenters that rely on different recycler items Library changes: Add feature logging capability for presenters and recyclerviews, see Logging.kt Allow child presenter provider to leverage hooks for applying common fields to base presenters View delegates now post onViewAttached() on next event loop bindViewLifecycleOwner() has been renamed to regular bind(). There are now 3 bind methods to choose from, check documentation for more info. presenterLifeCycleOwner field has been removed onPresenterDestroyed() was previously not invoked on child presenters onCleared has been made final, rely on #onPresenterDestroyed instead Dependency updates: Updated Coroutine library to 1.3.0 for scope support Updated Kotlin to 1.3.50 Updated Build tools to 29.0.2 Amalia 0.3.7 2019-08_14 Library changes: Fix dependency issues with samples Amalia 0.3.6 2019-07_06 Library changes: Name space for library changed after adding second gradle module, docs reflect proper names. Amalia 0.3.5 2019-07_06 Library changes: Ensure coroutine scopes is present as separate android artifact Amalia 0.3.4 2019-06_26 Library changes: More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scopes as extension property to presenters ( https://github.com/vicidroiddev/amalia/issues/12 ) Amalia 0.3.3 2019-06_15 Library changes: Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 ) Amalia 0.3.2 2019-06_11 Library changes: Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f ) Amalia 0.3.1 2019-06-10 Library changes: Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 ) Amalia 0.3.0 2019-06-09 Note: This version will rely on android x saved state library to be included in your app. Library changes: Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 ) Dependency updates: com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test:runner:1.3.0-alpha01 Amalia 0.2.0 2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Change Log"},{"location":"changelog/#changelog-amalia","text":"","title":"Changelog - Amalia"},{"location":"changelog/#amalia-040","text":"2019-10_02","title":"Amalia 0.4.0"},{"location":"changelog/#new-module","text":"RecyclerView support Can support numerous presenters that rely on different recycler items","title":"New module:"},{"location":"changelog/#library-changes","text":"Add feature logging capability for presenters and recyclerviews, see Logging.kt Allow child presenter provider to leverage hooks for applying common fields to base presenters View delegates now post onViewAttached() on next event loop bindViewLifecycleOwner() has been renamed to regular bind(). There are now 3 bind methods to choose from, check documentation for more info. presenterLifeCycleOwner field has been removed onPresenterDestroyed() was previously not invoked on child presenters onCleared has been made final, rely on #onPresenterDestroyed instead","title":"Library changes:"},{"location":"changelog/#dependency-updates","text":"Updated Coroutine library to 1.3.0 for scope support Updated Kotlin to 1.3.50 Updated Build tools to 29.0.2","title":"Dependency updates:"},{"location":"changelog/#amalia-037","text":"2019-08_14","title":"Amalia 0.3.7"},{"location":"changelog/#library-changes_1","text":"Fix dependency issues with samples","title":"Library changes:"},{"location":"changelog/#amalia-036","text":"2019-07_06","title":"Amalia 0.3.6"},{"location":"changelog/#library-changes_2","text":"Name space for library changed after adding second gradle module, docs reflect proper names.","title":"Library changes:"},{"location":"changelog/#amalia-035","text":"2019-07_06","title":"Amalia 0.3.5"},{"location":"changelog/#library-changes_3","text":"Ensure coroutine scopes is present as separate android artifact","title":"Library changes:"},{"location":"changelog/#amalia-034","text":"2019-06_26","title":"Amalia 0.3.4"},{"location":"changelog/#library-changes_4","text":"More useful bind method provided which takes a lifecycleOwner and a lambda for states Add coroutine scopes as extension property to presenters ( https://github.com/vicidroiddev/amalia/issues/12 )","title":"Library changes:"},{"location":"changelog/#amalia-033","text":"2019-06_15","title":"Amalia 0.3.3"},{"location":"changelog/#library-changes_5","text":"Hooks for presenter should be initialized before loadInitialState ( https://github.com/vicidroiddev/amalia/issues/17 )","title":"Library changes:"},{"location":"changelog/#amalia-032","text":"2019-06_11","title":"Amalia 0.3.2"},{"location":"changelog/#library-changes_6","text":"Remove unnecessary argument for lifecycleowner when observing events ( https://github.com/vicidroiddev/amalia/commit/975f5254826d49c6826a71fb279f837740592c7f )","title":"Library changes:"},{"location":"changelog/#amalia-031","text":"2019-06-10","title":"Amalia 0.3.1"},{"location":"changelog/#library-changes_7","text":"Remove live data from ViewDelegate interface ( https://github.com/vicidroiddev/amalia/issues/15 )","title":"Library changes:"},{"location":"changelog/#amalia-030","text":"2019-06-09 Note: This version will rely on android x saved state library to be included in your app.","title":"Amalia 0.3.0"},{"location":"changelog/#library-changes_8","text":"Add automatic handling of savedInstanceState to amalia components ( https://github.com/vicidroiddev/amalia/issues/2 ) Improve overrides in presenter for save state handling ( https://github.com/vicidroiddev/amalia/issues/11 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Library changes:"},{"location":"changelog/#dependency-updates_1","text":"com.android.tools.build:gradle:3.5.0-beta05 androidx.constraintlayout:constraintlayout:2.0.0-beta2 androidx.core:core-ktx:1.2.0-alpha02' androidx.test.espresso:espresso-core:3.3.0-alpha01 androidx.test:runner:1.3.0-alpha01","title":"Dependency updates:"},{"location":"changelog/#amalia-020","text":"2019-06-04 Add lifecycle methods to view delegate ( https://github.com/vicidroiddev/amalia/issues/4 ) Enhance the concept of binding to a presenter ( https://github.com/vicidroiddev/amalia/issues/5 ) Pushstate should resolve the correct thread ( https://github.com/vicidroiddev/amalia/issues/6 ) Abstract ViewDelegate functionality to an interface ( https://github.com/vicidroiddev/amalia/issues/13 )","title":"Amalia 0.2.0"},{"location":"gettingstarted/","text":"Adding gradle dependency Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url https://jitpack.io } } } Now add the amalia dependency in your app level build.gradle file. implementation ( com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar ) { transitive = true } 1. Define states and events You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state - ViewDelegate renders the state ViewDelegate pushes event - Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () } 2. Define presenter Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter DiscoverState , DiscoverEvent () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate DiscoverState , DiscoverEvent ) { Log . v ( DiscoverPresenter , View was bound to presenter ) } override fun onViewEvent ( event : DiscoverEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite - { repository . saveFavouriteShow ( event . show ) } } } } 3. Define view delegate Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate DiscoverTvState , DiscoverTvEvent ( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded - { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } } 4. Bind the presenter and delegate Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"Getting Started"},{"location":"gettingstarted/#adding-gradle-dependency","text":"Amalia is available via Jitpack Include the jitpack maven repository in your root level build.gradle file. allprojects { repositories { maven { url https://jitpack.io } } } Now add the amalia dependency in your app level build.gradle file. implementation ( com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar ) { transitive = true }","title":"Adding gradle dependency"},{"location":"gettingstarted/#1-define-states-and-events","text":"You can define states representing a snapshot in time of what the view should render. Sealed classes are perfect for this! You can also define the UI events that can be propagated to the presenter for further processing. In short: Presenter pushes state - ViewDelegate renders the state ViewDelegate pushes event - Presenter processes the event sealed class DiscoverState : ViewState { data class Loaded ( val data : DiscoverTvResult ) : DiscoverState () } sealed class DiscoverEvent : ViewEvent { object MarkShowAsFavourite : DiscoverEvent () }","title":"1. Define states and events"},{"location":"gettingstarted/#2-define-presenter","text":"Extend from the BasePresenter class and load all your data here. When you are finished loading, push an appropriate state. Before loading, you can push a state to represent loading . This can be rendered in the view event as a progress dialog or an empty state view. class DiscoverTvPresenter () : BasePresenter DiscoverState , DiscoverEvent () { private val repository = DiscoverTvRepository () override fun loadInitialState () { val results = repository . getDiscoverTvResults () pushState ( DiscoverState . Loaded ( results )) } override fun onBindViewDelegate ( viewDelegate : ViewDelegate DiscoverState , DiscoverEvent ) { Log . v ( DiscoverPresenter , View was bound to presenter ) } override fun onViewEvent ( event : DiscoverEvent ) { when ( event ) { is DiscoverEvent . MarkShowAsFavourite - { repository . saveFavouriteShow ( event . show ) } } } }","title":"2. Define presenter"},{"location":"gettingstarted/#3-define-view-delegate","text":"Extend from the BaseViewDelegate class or some other derivative if lists are required. Override renderViewState and apply UI changes as needed. Apply your onclick listeners and push the appropriate event to your presenter for processing. class DiscoverTvViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : BaseViewDelegate DiscoverTvState , DiscoverTvEvent ( lifecycleOwner , view ) { val tvShow : TextView = view . findViewById ( R . id . discover_tv_name ) val lastAiredDate : TextView = view . findViewById ( R . id . discover_tv_last_aired ) val favouriteBtn : Button = view . findViewById ( R . id . discover_tv_fav_btn ) init { favouriteBtn . setOnClickListener { pushEvent ( DiscoverTvEvent . MarkShowAsFavourite )} } override fun renderViewState ( state : DiscoverTvState ) { when ( state ) { is DiscoverState . Loaded - { tvShow . setText ( state . show . name ) lastAiredDate . setText ( state . show . lastAiredDate ) } } } }","title":"3. Define view delegate"},{"location":"gettingstarted/#4-bind-the-presenter-and-delegate","text":"Bind the presenter and the view delegate together. This can be done in an activity, fragment, or even a custom view. Leverage the presenterProvider to ensure your presenter is lifecycle aware and retained across configuration changes. class DiscoverTvActivity : BaseActivity () { private val discoverTvPresenter by presenterProvider { DiscoverTvPresenter () } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_main ) discoverTvPresenter . bind ( DiscoverTvViewDelegate ( this , window . decorView . rootView )) } }","title":"4. Bind the presenter and delegate"},{"location":"components/presenters/","text":"Presenters Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState (...) to expose a meaningful ViewState . Should inherit from BasePresenter ViewState , ViewEvent Should override onViewEvent (...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration Is there a callback for when my presenter is ready to go? class MyPresenter : BasePresenter ViewState , ViewEvent () { override fun loadInitialState () { // Can access applicationContext at this point applicationContext . getString ( R . string . somestring ) } } Is there a callback for when my presenter is destroyed? onPresenterDestroyed () will be invoked when the presenter is about to die. This will also be called for child presenters. This method is not invoked on configuration changes. class MyPresenter : BasePresenter ViewState , ViewEvent () { override fun onPresenterDestroyed () { // Clean up time // Even better track your closeable objects, see below } } What's a good way to clean up long running operations? You may store your object in the presenter cache if it implements Closeable . That way you can be sure it is automatically cleaned up at the right time. Note: Amalia uses this mechanism for amalia - coroutine - scopes module. class MyPresenter : BasePresenter ViewState , ViewEvent () { init { val longRunningThing = LongRunningThing () // Objects will automatically have close() called when the presenter is destroyed. closeableObjects . put ( my_key , longRunningThing ) } // Ensure we implement Closeable and cancel any operations needed. class LongRunningThing : Closeable { override fun close () { // Stop long running thing } } }","title":"Presenters"},{"location":"components/presenters/#presenters","text":"Should perform all data loading/saving/refreshing (anything background heavy) Will survive configuration changes (member fields stay in tact) Should leverage pushState (...) to expose a meaningful ViewState . Should inherit from BasePresenter ViewState , ViewEvent Should override onViewEvent (...) to process incoming ViewEvents Should never contain views, or activity contexts that may leak Can leverage the application context field to get resources Can use savedStateHandle for process death restoration","title":"Presenters"},{"location":"components/presenters/#is-there-a-callback-for-when-my-presenter-is-ready-to-go","text":"class MyPresenter : BasePresenter ViewState , ViewEvent () { override fun loadInitialState () { // Can access applicationContext at this point applicationContext . getString ( R . string . somestring ) } }","title":"Is there a callback for when my presenter is ready to go?"},{"location":"components/presenters/#is-there-a-callback-for-when-my-presenter-is-destroyed","text":"onPresenterDestroyed () will be invoked when the presenter is about to die. This will also be called for child presenters. This method is not invoked on configuration changes. class MyPresenter : BasePresenter ViewState , ViewEvent () { override fun onPresenterDestroyed () { // Clean up time // Even better track your closeable objects, see below } }","title":"Is there a callback for when my presenter is destroyed?"},{"location":"components/presenters/#whats-a-good-way-to-clean-up-long-running-operations","text":"You may store your object in the presenter cache if it implements Closeable . That way you can be sure it is automatically cleaned up at the right time. Note: Amalia uses this mechanism for amalia - coroutine - scopes module. class MyPresenter : BasePresenter ViewState , ViewEvent () { init { val longRunningThing = LongRunningThing () // Objects will automatically have close() called when the presenter is destroyed. closeableObjects . put ( my_key , longRunningThing ) } // Ensure we implement Closeable and cancel any operations needed. class LongRunningThing : Closeable { override fun close () { // Stop long running thing } } }","title":"What's a good way to clean up long running operations?"},{"location":"components/viewdelegates/","text":"ViewDelegates Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate ViewState , ViewEvent Should override renderViewState (...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent (...) to expose a meaningful ViewEvent","title":"View Delegate"},{"location":"components/viewdelegates/#viewdelegates","text":"Should perform all view related tasks and be fairly dumb (no business logic) Should inherit from BaseViewDelegate ViewState , ViewEvent Should override renderViewState (...) to process incoming ViewStates Can contain contexts, views or anything else that you would normally put in an Activity/Fragment Should contain your findViewById calls Should contain your various view listeners ( onClick , onCheckChanged etc..) Should leverage pushEvent (...) to expose a meaningful ViewEvent","title":"ViewDelegates"},{"location":"components/viewevents/","text":"ViewEvent Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent ( event : E ) to receive the SaveProfile event that was just sent.","title":"View Event"},{"location":"components/viewevents/#viewevent","text":"Create your own ViewEvent by implementing the ViewEvent interface. sealed class ProfileViewEvent : ViewEvent { class SaveProfile ( val profile : Profile ) : ProfileViewEvent () object CancelEditProfile () : ProfileViewEvent () } In your view delegate, in any appropriate listener you could fire an event: // Can only be called from the main thread. pushEvent ( ProfileViewEvent . SaveProfile ( profile )) In your presenter, override onViewEvent ( event : E ) to receive the SaveProfile event that was just sent.","title":"ViewEvent"},{"location":"components/viewstates/","text":"ViewState Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState ( state : S ) to receive the ProfileLoaded state that was just sent.","title":"View State"},{"location":"components/viewstates/#viewstate","text":"Create your own ViewState by implementing the ViewState interface. sealed class ProfileViewState : ViewState { class ProfileLoaded ( val profile : Profile ) : ProfileViewState () object NoProfileFound : ProfileViewState () } In your presenter, after performing database queries in the background call: // Can be called from a background thread pushState ( ProfileViewState . ProfileLoaded ( profile )) In your view delegate, override renderViewState ( state : S ) to receive the ProfileLoaded state that was just sent.","title":"ViewState"},{"location":"modules/coroutinescopes/","text":"Coroutine Scopes All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider . Available scopes in a presenter extending from BasePresenter * , * mainScope . launch { //uses the coroutine Main dispatcher, preferred scope for presenters } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher } Adding gradle dependency Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar Example usage: class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter DiscoverState , DiscoverEvent () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Coroutine Scopes"},{"location":"modules/coroutinescopes/#coroutine-scopes","text":"All provided coroutine scope extensions are cancelled when the presenter goes through destruction, dictated by the presenterProvider .","title":"Coroutine Scopes"},{"location":"modules/coroutinescopes/#available-scopes-in-a-presenter-extending-frombasepresenter","text":"mainScope . launch { //uses the coroutine Main dispatcher, preferred scope for presenters } ioScope . launch { //uses the coroutine IO dispatcher } defaultScope . launch { //uses the default coroutine dispatcher }","title":"Available scopes in a presenter extending from&lt;BasePresenter&lt;*,*&gt;"},{"location":"modules/coroutinescopes/#adding-gradle-dependency","text":"Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar","title":"Adding gradle dependency"},{"location":"modules/coroutinescopes/#example-usage","text":"class DiscoverPresenter ( private val repository : DiscoverRepository ) : BasePresenter DiscoverState , DiscoverEvent () { override fun loadInitialState () { // mainScope is provided via amalia-coroutine-scopes dependency mainScope . launch { // discoverFromApi is a suspending function which runs on the io dispatcher // if it takes a long time and the view is closed, we will automatically call cancel() on the scope. val results = repository . discoverFromApi () //Okay main thread here, lets push the view state pushState ( DiscoverState . Loaded ( results )) } } }","title":"Example usage:"},{"location":"modules/modules/","text":"Dependencies Amalia Core implementation ( com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar ) { transitive = true } Coroutine Scope Helper implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar RecyclerView Helper (0.4.0+) implementation com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar","title":"Dependencies"},{"location":"modules/modules/#dependencies","text":"","title":"Dependencies"},{"location":"modules/modules/#amalia-core","text":"implementation ( com.github.vicidroiddev.amalia:amalia-core:{latest_version}@aar ) { transitive = true }","title":"Amalia Core"},{"location":"modules/modules/#coroutine-scope-helper","text":"implementation com.github.vicidroiddev.amalia:amalia-coroutine-scopes:{latest_version}@aar","title":"Coroutine Scope Helper"},{"location":"modules/modules/#recyclerview-helper-040","text":"implementation com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar","title":"RecyclerView Helper (0.4.0+)"},{"location":"modules/recyclerview/","text":"RecyclerView Backed Delegates This module gives plug and play support for simple and complex lists. You can build complex dashboards where each item in the RecyclerView is backed by a different presenter. If each card needs to own it's own logic for when to display - NO problem. You can also create simple lists that are composed of different view items, such as cards, headers, etc... Out of the box you will get: Async diff support (send a bunch of items via pushState, only the items that changed will be processed) A wrapper around RecyclerView that allows you to focus on your own display logic Adding gradle dependency Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar 1. Create your own RecyclerViewDelegate This is the view layer. You likely won't have much code to put in here. You can customize some options such as spacing or layout managers for the recyclerview if needed. See the constructor for additional options. class MyLongListViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : RecyclerViewDelegate DiscoverTvItem , DiscoverTvItem . ViewHolder ( lifecycleOwner , view , R . id . the_recyclerview_id ) { } 2. Create a recycler item to bind data to view class MyRecyclerViewItem ( val myItem : MyItem ) : BaseRecyclerItem DiscoverTvItem . ViewHolder ( discoverResult ) { // Pass a layout represented by the given item to display - CardView for example override val layoutRes = R . layout . my_list_item_layout override fun createViewHolder ( itemView : View ) = MyViewHolder ( itemView ) override fun bind ( viewHolder : ViewHolder , payloads : List ChangePayload DiffItem ) { with ( viewHolder ) { // bind myItem to the view here name . text = myItem . name } } class MyViewHolder ( itemView : View ) : BaseRecyclerViewHolder ( itemView ) { val name : TextView = findViewById ( R . id . my_name ) init { // Set onclick listeners here or any other view listeners // Push events here to be processed by your presenter } } } 3. Emit recycler items with a presenter class MyLongListPresenter ( private val repository : MyRepository ) : BasePresenter RecyclerViewState MyRecyclerViewItem , ViewEvent (), Refreshable { private var results : MutableList DiscoverResult = mutableListOf () override fun loadInitialState () { mainScope . launch { // Make a suspending call that could be expensive, get a long list of items from a db for example. val items = repository . fetchItems () // Convert that data item (regular POJO class) to a RecyclerItem val viewItems = items . map { myItem - MyRecyclerViewItem ( myItem ) } pushState ( RecyclerViewState . ListLoaded ( viewItems )) } } } 4. Don't forget to bind the presenter and delegate! See getting started section for how to perform binding.","title":"RecyclerView Delegate"},{"location":"modules/recyclerview/#recyclerview-backed-delegates","text":"This module gives plug and play support for simple and complex lists. You can build complex dashboards where each item in the RecyclerView is backed by a different presenter. If each card needs to own it's own logic for when to display - NO problem. You can also create simple lists that are composed of different view items, such as cards, headers, etc... Out of the box you will get: Async diff support (send a bunch of items via pushState, only the items that changed will be processed) A wrapper around RecyclerView that allows you to focus on your own display logic","title":"RecyclerView Backed Delegates"},{"location":"modules/recyclerview/#adding-gradle-dependency","text":"Add the amalia dependency in your app level build.gradle file. implementation com.github.vicidroiddev.amalia:amalia-recyclerview:{latest_version}@aar","title":"Adding gradle dependency"},{"location":"modules/recyclerview/#1-create-your-own-recyclerviewdelegate","text":"This is the view layer. You likely won't have much code to put in here. You can customize some options such as spacing or layout managers for the recyclerview if needed. See the constructor for additional options. class MyLongListViewDelegate ( lifecycleOwner : LifecycleOwner , view : View ) : RecyclerViewDelegate DiscoverTvItem , DiscoverTvItem . ViewHolder ( lifecycleOwner , view , R . id . the_recyclerview_id ) { }","title":"1. Create your own RecyclerViewDelegate"},{"location":"modules/recyclerview/#2-create-a-recycler-item-to-bind-data-to-view","text":"class MyRecyclerViewItem ( val myItem : MyItem ) : BaseRecyclerItem DiscoverTvItem . ViewHolder ( discoverResult ) { // Pass a layout represented by the given item to display - CardView for example override val layoutRes = R . layout . my_list_item_layout override fun createViewHolder ( itemView : View ) = MyViewHolder ( itemView ) override fun bind ( viewHolder : ViewHolder , payloads : List ChangePayload DiffItem ) { with ( viewHolder ) { // bind myItem to the view here name . text = myItem . name } } class MyViewHolder ( itemView : View ) : BaseRecyclerViewHolder ( itemView ) { val name : TextView = findViewById ( R . id . my_name ) init { // Set onclick listeners here or any other view listeners // Push events here to be processed by your presenter } } }","title":"2. Create a recycler item to bind data to view"},{"location":"modules/recyclerview/#3-emit-recycler-items-with-a-presenter","text":"class MyLongListPresenter ( private val repository : MyRepository ) : BasePresenter RecyclerViewState MyRecyclerViewItem , ViewEvent (), Refreshable { private var results : MutableList DiscoverResult = mutableListOf () override fun loadInitialState () { mainScope . launch { // Make a suspending call that could be expensive, get a long list of items from a db for example. val items = repository . fetchItems () // Convert that data item (regular POJO class) to a RecyclerItem val viewItems = items . map { myItem - MyRecyclerViewItem ( myItem ) } pushState ( RecyclerViewState . ListLoaded ( viewItems )) } } }","title":"3. Emit recycler items with a presenter"},{"location":"modules/recyclerview/#4-dont-forget-to-bind-the-presenter-and-delegate","text":"See getting started section for how to perform binding.","title":"4. Don't forget to bind the presenter and delegate!"}]}